using System.Diagnostics;
using System.Diagnostics.Metrics;
using SemanticKernel.Connectors.OpenRouter.Models;

namespace SemanticKernel.Connectors.OpenRouter.Core;

internal static class OpenRouterTelemetry
{
    internal const string ActivitySourceName = "Microsoft.SemanticKernel.Connectors.OpenRouter";
    internal const string MeterName = "Microsoft.SemanticKernel.Connectors.OpenRouter";

    internal static readonly ActivitySource ActivitySource = new(ActivitySourceName);
    internal static readonly Meter Meter = new(MeterName);

    // Duration metrics
    internal static readonly Histogram<double> ChatCompletionDuration = Meter.CreateHistogram<double>(
        name: "semantic_kernel.connectors.openrouter.chat_completion.duration",
        unit: "s",
        description: "Duration of OpenRouter chat completion requests");

    internal static readonly Histogram<double> StreamingChatCompletionDuration = Meter.CreateHistogram<double>(
        name: "semantic_kernel.connectors.openrouter.streaming_chat_completion.duration",
        unit: "s",
        description: "Duration of OpenRouter streaming chat completion requests");

    internal static readonly Histogram<double> TextGenerationDuration = Meter.CreateHistogram<double>(
        name: "semantic_kernel.connectors.openrouter.text_generation.duration",
        unit: "s",
        description: "Duration of OpenRouter text generation requests");

    // Token usage metrics
    internal static readonly Counter<int> PromptTokens = Meter.CreateCounter<int>(
        name: "semantic_kernel.connectors.openrouter.tokens.prompt",
        unit: "token",
        description: "Number of prompt tokens consumed by OpenRouter requests");

    internal static readonly Counter<int> CompletionTokens = Meter.CreateCounter<int>(
        name: "semantic_kernel.connectors.openrouter.tokens.completion",
        unit: "token",
        description: "Number of completion tokens generated by OpenRouter requests");

    internal static readonly Counter<int> TotalTokens = Meter.CreateCounter<int>(
        name: "semantic_kernel.connectors.openrouter.tokens.total",
        unit: "token",
        description: "Total number of tokens used by OpenRouter requests");

    // Request metrics
    internal static readonly Counter<int> RequestCount = Meter.CreateCounter<int>(
        name: "semantic_kernel.connectors.openrouter.requests.count",
        description: "Number of requests made to OpenRouter API");

    internal static readonly Counter<int> RequestErrors = Meter.CreateCounter<int>(
        name: "semantic_kernel.connectors.openrouter.requests.errors",
        description: "Number of failed requests to OpenRouter API");

    // Cost metrics (from OpenRouter generation details)
    internal static readonly Histogram<double> ActualCost = Meter.CreateHistogram<double>(
        name: "semantic_kernel.connectors.openrouter.cost.actual",
        unit: "USD",
        description: "Actual cost of OpenRouter requests in USD");

    internal static readonly Histogram<double> UpstreamCost = Meter.CreateHistogram<double>(
        name: "semantic_kernel.connectors.openrouter.cost.upstream",
        unit: "USD",
        description: "Upstream inference cost for BYOK requests");

    // Latency and generation time metrics
    internal static readonly Histogram<double> GenerationTime = Meter.CreateHistogram<double>(
        name: "semantic_kernel.connectors.openrouter.generation_time",
        unit: "s",
        description: "Time spent generating the response");

    internal static readonly Histogram<double> NetworkLatency = Meter.CreateHistogram<double>(
        name: "semantic_kernel.connectors.openrouter.latency",
        unit: "s",
        description: "Network latency for OpenRouter requests");

    // Native token metrics (accurate provider-specific counts)
    internal static readonly Counter<int> NativePromptTokens = Meter.CreateCounter<int>(
        name: "semantic_kernel.connectors.openrouter.tokens.native_prompt",
        unit: "token",
        description: "Native prompt tokens using provider's tokenizer");

    internal static readonly Counter<int> NativeCompletionTokens = Meter.CreateCounter<int>(
        name: "semantic_kernel.connectors.openrouter.tokens.native_completion",
        unit: "token",
        description: "Native completion tokens using provider's tokenizer");

    internal static readonly Counter<int> NativeTotalTokens = Meter.CreateCounter<int>(
        name: "semantic_kernel.connectors.openrouter.tokens.native_total",
        unit: "token",
        description: "Total native tokens using provider's tokenizer");

    internal static class ActivityNames
    {
        internal const string ChatCompletion = "openrouter.chat_completion";
        internal const string StreamingChatCompletion = "openrouter.streaming_chat_completion";
        internal const string TextGeneration = "openrouter.text_generation";
    }

    internal static class TagNames
    {
        internal const string ModelId = "semantic_kernel.model_id";
        internal const string Provider = "semantic_kernel.ai_provider";
        internal const string OperationType = "semantic_kernel.operation_type";
        internal const string IsStreaming = "semantic_kernel.is_streaming";
        internal const string StatusCode = "http.status_code";
        internal const string ErrorType = "error.type";
        internal const string RequestId = "semantic_kernel.request_id";
    }

    internal static class OperationTypes
    {
        internal const string ChatCompletion = "chat_completion";
        internal const string TextGeneration = "text_generation";
    }

    internal static TagList CreateTags(string modelId, string operationType, bool isStreaming = false, string? requestId = null)
    {
        var tags = new TagList
        {
            { TagNames.ModelId, modelId },
            { TagNames.Provider, "openrouter" },
            { TagNames.OperationType, operationType },
            { TagNames.IsStreaming, isStreaming.ToString().ToLowerInvariant() }
        };

        if (!string.IsNullOrEmpty(requestId))
        {
            tags.Add(TagNames.RequestId, requestId);
        }

        return tags;
    }

    internal static void RecordTokenUsage(TagList tags, int promptTokens, int completionTokens, int totalTokens)
    {
        PromptTokens.Add(promptTokens, tags);
        CompletionTokens.Add(completionTokens, tags);
        TotalTokens.Add(totalTokens, tags);
    }

    internal static void RecordDuration(string operationType, double durationSeconds, TagList tags)
    {
        switch (operationType)
        {
            case OperationTypes.ChatCompletion when tags.Any(t => t.Key == TagNames.IsStreaming && t.Value?.ToString() == "true"):
                StreamingChatCompletionDuration.Record(durationSeconds, tags);
                break;
            case OperationTypes.ChatCompletion:
                ChatCompletionDuration.Record(durationSeconds, tags);
                break;
            case OperationTypes.TextGeneration:
                TextGenerationDuration.Record(durationSeconds, tags);
                break;
        }
    }

    internal static void RecordRequest(TagList tags, bool isError = false)
    {
        RequestCount.Add(1, tags);
        if (isError)
        {
            RequestErrors.Add(1, tags);
        }
    }

    internal static void RecordGenerationMetrics(TagList tags, OpenRouterGeneration generation)
    {
        // Record costs
        if (generation.TotalCost.HasValue && generation.TotalCost.Value > 0)
        {
            ActualCost.Record(generation.TotalCost.Value, tags);
        }

        if (generation.UpstreamInferenceCost.HasValue && generation.UpstreamInferenceCost.Value > 0)
        {
            UpstreamCost.Record(generation.UpstreamInferenceCost.Value, tags);
        }

        // Record native token usage (accurate counts)
        NativePromptTokens.Add(generation.NativeTokensPrompt, tags);
        NativeCompletionTokens.Add(generation.NativeTokensCompletion, tags);
        NativeTotalTokens.Add(generation.GetTotalNativeTokens(), tags);

        // Record timing metrics
        if (generation.GenerationTime.HasValue && generation.GenerationTime.Value > 0)
        {
            GenerationTime.Record(generation.GenerationTime.Value, tags);
        }

        if (generation.Latency.HasValue && generation.Latency.Value > 0)
        {
            NetworkLatency.Record(generation.Latency.Value, tags);
        }
    }
}